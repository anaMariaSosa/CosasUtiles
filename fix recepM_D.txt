import pandas as pd
from typing import Iterable, Optional

def chequear_primer_movimiento_no_valor_simple(
    f1: pd.DataFrame,
    pieza_col: str,
    fecha_col: str,
    valor_col: str,
    valores_prohibidos: Iterable,
    f2: Optional[pd.DataFrame] = None,
    f3: Optional[pd.DataFrame] = None,
    condicion_en_f2: Optional[bool] = None,
    condicion_en_f3: Optional[bool] = None,
) -> pd.DataFrame:
    """
    Regla: sólo evalúo piezas que existen en f1. Si el primer valor está vacío, no evalúo.
    Opcionalmente condiciono por presencia/ausencia en f2 y/o f3.
    """

    if f1 is None or f1.empty:
        return pd.DataFrame(columns=[pieza_col, "fecha_primera", "valor_primero"])

    # Asegurar fecha
    dft = f1.copy()
    dft[fecha_col] = pd.to_datetime(dft[fecha_col], errors="coerce")

    # Primer movimiento por pieza (fecha mínima)
    idx = dft.groupby(pieza_col)[fecha_col].idxmin()
    first_rows = dft.loc[idx, [pieza_col, fecha_col, valor_col]].copy()
    first_rows.rename(columns={fecha_col: "fecha_primera", valor_col: "valor_primero"}, inplace=True)

    # Ignorar piezas cuyo primer valor está vacío
    mask_val = first_rows["valor_primero"].notna() & (first_rows["valor_primero"].astype(str).str.strip() != "")
    first_rows = first_rows[mask_val]
    if first_rows.empty:
        return pd.DataFrame(columns=[pieza_col, "fecha_primera", "valor_primero"])

    # Si no hay condiciones, aplica siempre
    aplica = pd.Series(True, index=first_rows.index)

    # Condición en f2 (si se pide)
    if condicion_en_f2 is not None:
        if f2 is None or f2.empty:
            # No puedo comprobar f2 → hago que NO aplique (así no hay falsos positivos)
            aplica &= False
        else:
            presentes_f2 = first_rows[[pieza_col]].merge(
                f2[[pieza_col]].drop_duplicates().assign(__p=True),
                on=pieza_col, how="left"
            )["__p"].fillna(False)
            # True si coincide la presencia con la condición
            aplica &= (presentes_f2 == condicion_en_f2)

    # Condición en f3 (si se pide)
    if condicion_en_f3 is not None:
        if f3 is None or f3.empty:
            aplica &= False
        else:
            presentes_f3 = first_rows[[pieza_col]].merge(
                f3[[pieza_col]].drop_duplicates().assign(__p=True),
                on=pieza_col, how="left"
            )["__p"].fillna(False)
            aplica &= (presentes_f3 == condicion_en_f3)

    # Violaciones: aplica la regla y el primer valor es prohibido
    violaciones = first_rows[aplica & first_rows["valor_primero"].isin(set(valores_prohibidos))].copy()
    violaciones.sort_values(by=[pieza_col], inplace=True)
    violaciones.reset_index(drop=True, inplace=True)
    return violaciones
