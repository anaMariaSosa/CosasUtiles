def chequear_primer_movimiento_no_valor(
    f1: pd.DataFrame,
    pieza_col: str,
    fecha_col: str,
    valor_col: str,
    valores_prohibidos: Iterable,
    f2: Optional[pd.DataFrame] = None,
    f3: Optional[pd.DataFrame] = None,
    clave_cols_f2: Optional[Union[str, List[str]]] = None,
    clave_cols_f3: Optional[Union[str, List[str]]] = None,
    condicion_en_f2: Optional[bool] = None,
    condicion_en_f3: Optional[bool] = None,
    piezas_a_chequear: Optional[Union[pd.Series, pd.DataFrame, Iterable]] = None,
) -> pd.DataFrame:
    """
    Chequea que el PRIMER movimiento en f1 NO puede ser un valor (X o Y) si se cumplen
    condiciones de presencia (está / no está) en f2 y/o f3.

    Comportamiento clave:
    - Si una pieza NO EXISTE en f1, NO se chequea (no hay violación posible).
    - Si `piezas_a_chequear` está definido, se limita el universo a esas piezas;
      las que no estén en f1 se ignoran (no se chequean).
    - Si el valor del primer movimiento es NaN/None/"" se ignora la pieza (no se evalúa).
    """
    if f1 is None or f1.empty:
        return pd.DataFrame(columns=[pieza_col, "fecha_primera", "valor_primero", "aplica_regla_f2", "aplica_regla_f3"])

    dft = _ensure_datetime(f1, fecha_col)

    if piezas_a_chequear is not None:
        if isinstance(piezas_a_chequear, pd.DataFrame):
            if pieza_col not in piezas_a_chequear.columns:
                raise ValueError(f"'piezas_a_chequear' debe contener la columna '{pieza_col}'.")
            universo = set(piezas_a_chequear[pieza_col].dropna().unique().tolist())
        elif isinstance(piezas_a_chequear, pd.Series):
            universo = set(piezas_a_chequear.dropna().unique().tolist())
        else:
            universo = set(list(piezas_a_chequear))
        dft = dft[dft[pieza_col].isin(universo)]
        if dft.empty:
            return pd.DataFrame(columns=[pieza_col, "fecha_primera", "valor_primero", "aplica_regla_f2", "aplica_regla_f3"])

    grp = dft.groupby(pieza_col)[fecha_col]
    if grp.ngroups == 0:
        return pd.DataFrame(columns=[pieza_col, "fecha_primera", "valor_primero", "aplica_regla_f2", "aplica_regla_f3"])

    first_rows = dft.loc[grp.idxmin(), [pieza_col, fecha_col, valor_col]].copy()
    first_rows.rename(columns={fecha_col: "fecha_primera", valor_col: "valor_primero"}, inplace=True)

    # ignorar piezas sin valor definido en el primer movimiento
    first_rows = first_rows[first_rows["valor_primero"].notna() & (first_rows["valor_primero"].astype(str).str.strip() != "")]
    if first_rows.empty:
        return pd.DataFrame(columns=[pieza_col, "fecha_primera", "valor_primero", "aplica_regla_f2", "aplica_regla_f3"])

    first_rows["aplica_regla_f2"] = True
    first_rows["aplica_regla_f3"] = True

    if condicion_en_f2 is not None and f2 is not None and not f2.empty:
        ccols2 = [pieza_col] if clave_cols_f2 is None else ([clave_cols_f2] if isinstance(clave_cols_f2, str) else clave_cols_f2)
        present_in_f2 = _presence_mask(first_rows[[pieza_col]], f2, ccols2).values
        first_rows["aplica_regla_f2"] = (present_in_f2 == condicion_en_f2)
    elif condicion_en_f2 is not None:
        first_rows["aplica_regla_f2"] = False  # no se puede evaluar → no aplica

    if condicion_en_f3 is not None and f3 is not None and not f3.empty:
        ccols3 = [pieza_col] if clave_cols_f3 is None else ([clave_cols_f3] if isinstance(clave_cols_f3, str) else clave_cols_f3)
        present_in_f3 = _presence_mask(first_rows[[pieza_col]], f3, ccols3).values
        first_rows["aplica_regla_f3"] = (present_in_f3 == condicion_en_f3)
    elif condicion_en_f3 is not None:
        first_rows["aplica_regla_f3"] = False

    masks = []
    if condicion_en_f2 is not None:
        masks.append(first_rows["aplica_regla_f2"])
    if condicion_en_f3 is not None:
        masks.append(first_rows["aplica_regla_f3"])
    aplica_regla = pd.Series(True, index=first_rows.index) if not masks else masks[0]
    for m in masks[1:]:
        aplica_regla = aplica_regla & m

    violaciones = first_rows[aplica_regla & first_rows["valor_primero"].isin(set(valores_prohibidos))].copy()
    violaciones.sort_values(by=[pieza_col], inplace=True)
    violaciones.reset_index(drop=True, inplace=True)
    return violaciones